/**
 * smoke-linear-api.test.ts — Live integration tests against the real Linear API.
 *
 * These tests verify API connectivity, comment lifecycle, and dedup behavior
 * using real API calls. Run separately from unit tests:
 *
 *   npx vitest run --config vitest.smoke.config.ts
 *
 * Requires: ~/.openclaw/auth-profiles.json with a valid linear:api-key profile.
 */
import { readFileSync, writeFileSync } from "node:fs";
import { join, dirname } from "node:path";
import { homedir } from "node:os";
import { fileURLToPath } from "node:url";
import { afterAll, beforeAll, describe, expect, it } from "vitest";
import { LinearAgentApi } from "../api/linear-api.js";

const __dirname = dirname(fileURLToPath(import.meta.url));

// ── Setup ──────────────────────────────────────────────────────────

const AUTH_PROFILES_PATH = join(
  homedir(),
  ".openclaw",
  "auth-profiles.json",
);

const TEAM_ID = "08cba264-d774-4afd-bc93-ee8213d12ef8";

function loadApiKey(): string {
  const raw = readFileSync(AUTH_PROFILES_PATH, "utf8");
  const store = JSON.parse(raw);
  const profile = store?.profiles?.["linear:api-key"];
  const token = profile?.accessToken ?? profile?.access;
  if (!token) throw new Error("No linear:api-key profile found in auth-profiles.json");
  return token;
}

function loadOAuthToken(): string | null {
  try {
    const raw = readFileSync(AUTH_PROFILES_PATH, "utf8");
    const store = JSON.parse(raw);
    const profile = store?.profiles?.["linear:default"];
    return profile?.accessToken ?? null;
  } catch {
    return null;
  }
}

let api: LinearAgentApi;
let oauthApi: LinearAgentApi | null = null;
let smokeIssueId: string | null = null;
const createdCommentIds: string[] = [];

beforeAll(() => {
  const token = loadApiKey();
  api = new LinearAgentApi(token);
  const oauthToken = loadOAuthToken();
  if (oauthToken) {
    // Strip "Bearer " prefix if present — LinearAgentApi adds it
    const bare = oauthToken.replace(/^Bearer\s+/i, "");
    oauthApi = new LinearAgentApi(bare);
  }
});

afterAll(async () => {
  // Cleanup: we can't delete comments via API, but they're prefixed
  // with [SMOKE TEST] for easy identification.
  if (createdCommentIds.length > 0) {
    console.log(
      `Smoke test created ${createdCommentIds.length} comment(s) prefixed with [SMOKE TEST]. ` +
      `Clean up manually if needed.`,
    );
  }
});

// ── Tests ──────────────────────────────────────────────────────────

describe("Linear API smoke tests", () => {
  describe("connectivity", () => {
    it("resolves viewer ID", async () => {
      const viewerId = await api.getViewerId();
      expect(viewerId).toBeTruthy();
      expect(typeof viewerId).toBe("string");
    });
  });

  describe("team discovery", () => {
    it("lists teams", async () => {
      const teams = await api.getTeams();
      expect(teams.length).toBeGreaterThan(0);
      expect(teams[0]).toHaveProperty("id");
      expect(teams[0]).toHaveProperty("name");
      expect(teams[0]).toHaveProperty("key");
    });

    it("finds our configured team", async () => {
      const teams = await api.getTeams();
      const ourTeam = teams.find((t) => t.id === TEAM_ID);
      expect(ourTeam).toBeTruthy();
    });

    it("lists team labels", async () => {
      const labels = await api.getTeamLabels(TEAM_ID);
      expect(Array.isArray(labels)).toBe(true);
      // Labels may or may not exist, but the call should succeed
    });

    it("lists team workflow states", async () => {
      const states = await api.getTeamStates(TEAM_ID);
      expect(states.length).toBeGreaterThan(0);
      expect(states[0]).toHaveProperty("id");
      expect(states[0]).toHaveProperty("name");
      expect(states[0]).toHaveProperty("type");
      // Should have at least backlog, started, completed types
      const types = states.map((s) => s.type);
      expect(types).toContain("backlog");
    });
  });

  describe("issue operations", () => {
    it("creates a smoke test issue", async () => {
      const states = await api.getTeamStates(TEAM_ID);
      const backlogState = states.find((s) => s.type === "backlog");
      expect(backlogState).toBeTruthy();

      const result = await api.createIssue({
        teamId: TEAM_ID,
        title: "[SMOKE TEST] Linear Plugin Integration Test",
        description:
          "Auto-generated by smoke tests. Safe to delete.\n\n" +
          `Created: ${new Date().toISOString()}`,
        stateId: backlogState!.id,
        priority: 4, // Low
      });

      expect(result.id).toBeTruthy();
      expect(result.identifier).toBeTruthy();
      smokeIssueId = result.id;
    });

    it("reads issue details", async () => {
      expect(smokeIssueId).toBeTruthy();
      const issue = await api.getIssueDetails(smokeIssueId!);

      expect(issue.id).toBe(smokeIssueId);
      expect(issue.identifier).toBeTruthy();
      expect(issue.title).toContain("[SMOKE TEST]");
      expect(issue.state).toHaveProperty("name");
      expect(issue.team).toHaveProperty("id");
      expect(issue.team).toHaveProperty("name");
      expect(issue.labels).toHaveProperty("nodes");
      expect(issue.comments).toHaveProperty("nodes");
    });

    it("updates issue fields", async () => {
      expect(smokeIssueId).toBeTruthy();
      const success = await api.updateIssue(smokeIssueId!, {
        estimate: 1,
        priority: 4,
      });
      expect(success).toBe(true);

      // Verify the update
      const issue = await api.getIssueDetails(smokeIssueId!);
      expect(issue.estimate).toBe(1);
    });
  });

  describe("comment lifecycle", () => {
    it("creates a comment", async () => {
      expect(smokeIssueId).toBeTruthy();
      const commentId = await api.createComment(
        smokeIssueId!,
        "[SMOKE TEST] Comment created by integration test.\n\n" +
        `Timestamp: ${new Date().toISOString()}`,
      );
      expect(commentId).toBeTruthy();
      expect(typeof commentId).toBe("string");
      createdCommentIds.push(commentId);
    });

    it("comment appears in issue details", async () => {
      expect(smokeIssueId).toBeTruthy();
      expect(createdCommentIds.length).toBeGreaterThan(0);

      const issue = await api.getIssueDetails(smokeIssueId!);
      const comments = issue.comments.nodes;
      const found = comments.some((c) =>
        c.body.includes("[SMOKE TEST] Comment created by integration test"),
      );
      expect(found).toBe(true);
    });

    it("creates an agent identity comment (requires OAuth — skipped with API key)", async () => {
      expect(smokeIssueId).toBeTruthy();
      // createAsUser posts as a named OpenClaw agent (e.g. "Mal", "Kaylee")
      // with their avatar. Requires OAuth actor=app mode — personal API keys
      // can't use it, so comments fall back to a **[AgentName]** prefix.
      try {
        const commentId = await api.createComment(
          smokeIssueId!,
          "[SMOKE TEST] Agent identity comment test.",
          {
            createAsUser: "Smoke Test Bot",
            displayIconUrl: "https://avatars.githubusercontent.com/u/1?v=4",
          },
        );
        expect(commentId).toBeTruthy();
        createdCommentIds.push(commentId);
      } catch (err) {
        const msg = String(err);
        if (msg.includes("createAsUser") || msg.includes("actor=app")) {
          // Expected with API key — agent identity comments require OAuth
          expect(true).toBe(true);
        } else {
          throw err; // Unexpected error
        }
      }
    });
  });

  describe("issue state transitions", () => {
    let teamStates: Array<{ id: string; name: string; type: string }>;

    it("fetches team workflow states for transition tests", async () => {
      teamStates = await api.getTeamStates(TEAM_ID);
      expect(teamStates.length).toBeGreaterThan(0);
    });

    it("transitions issue from backlog to started", async () => {
      expect(smokeIssueId).toBeTruthy();
      const startedState = teamStates.find((s) => s.type === "started");
      expect(startedState).toBeTruthy();

      const success = await api.updateIssue(smokeIssueId!, { stateId: startedState!.id });
      expect(success).toBe(true);

      const issue = await api.getIssueDetails(smokeIssueId!);
      expect(issue.state.type).toBe("started");
    });

    it("transitions issue from started to completed", async () => {
      expect(smokeIssueId).toBeTruthy();
      const completedState = teamStates.find((s) => s.type === "completed");
      expect(completedState).toBeTruthy();

      const success = await api.updateIssue(smokeIssueId!, { stateId: completedState!.id });
      expect(success).toBe(true);

      const issue = await api.getIssueDetails(smokeIssueId!);
      expect(issue.state.type).toBe("completed");
    });

    it("transitions issue from completed to canceled", async () => {
      expect(smokeIssueId).toBeTruthy();
      const canceledState = teamStates.find(
        (s) => s.type === "canceled" || s.name.toLowerCase().includes("cancel"),
      );
      expect(canceledState).toBeTruthy();

      const success = await api.updateIssue(smokeIssueId!, { stateId: canceledState!.id });
      expect(success).toBe(true);

      const issue = await api.getIssueDetails(smokeIssueId!);
      expect(issue.state.type).toBe("canceled");
    });
  });

  describe("@mention pattern matching", () => {
    it("buildMentionPattern matches configured aliases", async () => {
      // Test the pattern logic without needing agent-profiles.json.
      // Note: use match() not test() — test() with `g` flag is stateful.
      const aliases = ["mal", "kaylee", "inara", "zoe"];
      const escaped = aliases.map((a) =>
        a.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"),
      );
      const pattern = new RegExp(`@(${escaped.join("|")})`, "gi");

      expect("@mal please fix this".match(pattern)).toBeTruthy();
      expect("Hey @kaylee can you look at this?".match(pattern)).toBeTruthy();
      expect("@Inara write a blog post".match(pattern)).toBeTruthy();
      expect("No mention here".match(pattern)).toBeNull();
      expect("email@mal.com".match(pattern)).toBeTruthy(); // Known edge case
    });
  });

  describe("dedup dry run", () => {
    it("wasRecentlyProcessed returns false first, true second", async () => {
      // Import the dedup function
      const { _resetForTesting } = await import(
        "../pipeline/webhook.js"
      );
      _resetForTesting();

      // The wasRecentlyProcessed function is not exported directly,
      // but we can test it indirectly through the webhook handler.
      // For a pure unit test of the dedup function, see webhook-dedup.test.ts.
      // Here we just verify the reset works.
      expect(typeof _resetForTesting).toBe("function");
    });
  });

  describe("webhook management", () => {
    it("lists webhooks", async () => {
      const webhooks = await api.listWebhooks();
      expect(Array.isArray(webhooks)).toBe(true);
      // Should have at least the shape we expect
      if (webhooks.length > 0) {
        expect(webhooks[0]).toHaveProperty("id");
        expect(webhooks[0]).toHaveProperty("url");
        expect(webhooks[0]).toHaveProperty("enabled");
        expect(webhooks[0]).toHaveProperty("resourceTypes");
      }
    });

    it("getWebhookStatus reports issues on misconfigured webhook", async () => {
      const { getWebhookStatus } = await import("../../src/infra/webhook-provision.js");
      // Use a URL that won't match any real webhook — should return null
      const status = await getWebhookStatus(api, "https://nonexistent.example.com/webhook");
      expect(status).toBeNull();
    });

    it("getWebhookStatus finds our webhook if configured", async () => {
      const { getWebhookStatus } = await import("../../src/infra/webhook-provision.js");
      const status = await getWebhookStatus(
        api,
        "https://linear.calltelemetry.com/linear/webhook",
      );
      // May or may not exist — just check the function works
      if (status) {
        expect(status.id).toBeTruthy();
        expect(status.url).toBe("https://linear.calltelemetry.com/linear/webhook");
        expect(Array.isArray(status.issues)).toBe(true);
      }
    });

    it("provisionWebhook returns already_ok when correctly configured", async () => {
      const { provisionWebhook, getWebhookStatus } = await import("../../src/infra/webhook-provision.js");
      const status = await getWebhookStatus(
        api,
        "https://linear.calltelemetry.com/linear/webhook",
      );
      // Only run if our webhook exists and is correctly configured
      if (status && status.issues.length === 0) {
        const result = await provisionWebhook(
          api,
          "https://linear.calltelemetry.com/linear/webhook",
        );
        expect(result.action).toBe("already_ok");
        expect(result.webhookId).toBe(status.id);
      }
    });
  });

  describe("AgentSessionEvent webhook flow", () => {
    // Tests two paths that trigger AgentSessionEvent.created:
    //   Path A: @mention in a comment — user posts "@ctclaw do X" on an issue.
    //           Linear sees the agent mention, creates an AgentSession, and
    //           fires the webhook. This is the normal user flow.
    //   Path B: createSessionOnIssue API call — programmatic session creation
    //           (requires OAuth token, not API key).
    //
    // Both should result in the gateway receiving the webhook and spawning
    // an agent run. We verify by polling for agent comments on the issue.
    //
    // Requires:
    //   - OAuth app webhook → https://linear.calltelemetry.com/linear/webhook
    //   - Gateway running (systemctl --user status openclaw-gateway)

    let sessionIssueId: string | null = null;
    let sessionIssueIdentifier: string | null = null;

    it("creates a test issue for agent session", async () => {
      const states = await api.getTeamStates(TEAM_ID);
      const backlogState = states.find((s) => s.type === "backlog");
      expect(backlogState).toBeTruthy();

      const result = await api.createIssue({
        teamId: TEAM_ID,
        title: "[SMOKE TEST] AgentSessionEvent webhook test",
        description:
          "Auto-generated to test AgentSessionEvent webhook flow.\n" +
          "Tests both @mention and createSessionOnIssue paths.\n\n" +
          `Created: ${new Date().toISOString()}`,
        stateId: backlogState!.id,
        priority: 4,
      });

      expect(result.id).toBeTruthy();
      sessionIssueId = result.id;
      sessionIssueIdentifier = result.identifier;
      console.log(`Created test issue: ${result.identifier} (${result.id})`);
    });

    it("Path A: @mention triggers AgentSessionEvent", async () => {
      expect(sessionIssueId).toBeTruthy();

      // Post a comment mentioning @ctclaw — this is what real users do.
      // Linear should detect the agent @mention, create an AgentSession,
      // and fire AgentSessionEvent.created to our webhook.
      const commentId = await api.createComment(
        sessionIssueId!,
        "@ctclaw What is the status of this issue? [SMOKE TEST — ignore this]",
      );
      expect(commentId).toBeTruthy();
      createdCommentIds.push(commentId);
      console.log(`Posted @ctclaw mention comment: ${commentId}`);

      // Give Linear time to process the @mention → create session → fire webhook
      // → gateway receives → agent spawns → agent posts response
      console.log("Waiting 12s for webhook round-trip...");
      await new Promise((r) => setTimeout(r, 12000));

      // Check for agent activity on the issue
      const issue = await api.getIssueDetails(sessionIssueId!);
      const comments = issue.comments?.nodes ?? [];

      // Look for comments that aren't ours (agent responses)
      const agentComments = comments.filter(
        (c: any) =>
          !c.body?.includes("[SMOKE TEST]") &&
          c.id !== commentId,
      );

      if (agentComments.length > 0) {
        console.log(
          `@mention flow: ${agentComments.length} agent response(s) found — webhook flow confirmed!`,
        );
        // Preview first response
        const preview = agentComments[0].body?.slice(0, 120) ?? "(empty)";
        console.log(`  First response: ${preview}...`);
      } else {
        console.log(
          "@mention flow: No agent response yet. Possible causes:\n" +
          "  - @ctclaw not recognized as an agent mention by Linear\n" +
          "  - OAuth app webhook not configured or not pointing to gateway\n" +
          "  - Agent still processing (may take >12s for full response)\n" +
          "  Check: journalctl --user -u openclaw-gateway --since '1 min ago'",
        );
      }

      expect(issue.id).toBe(sessionIssueId);
    });

    it("Path B: createSessionOnIssue via OAuth (programmatic)", async () => {
      expect(sessionIssueId).toBeTruthy();

      // agentSessionCreateOnIssue requires OAuth — personal API keys get 403
      const sessionApi = oauthApi ?? api;
      const result = await sessionApi.createSessionOnIssue(sessionIssueId!);

      if (result.error) {
        if (result.error.includes("apiKey") || result.error.includes("FORBIDDEN")) {
          console.warn(
            "Path B skipped: createSessionOnIssue requires OAuth token. " +
            "Personal API keys get 403. Ensure linear:default has a valid OAuth token.",
          );
        } else {
          console.warn(`createSessionOnIssue error: ${result.error}`);
        }
      }
      if (result.sessionId) {
        expect(typeof result.sessionId).toBe("string");
        console.log(`Path B: Agent session created: ${result.sessionId}`);
      }
    });

    it("cleans up agent session test issue", async () => {
      if (!sessionIssueId) return;
      try {
        const states = await api.getTeamStates(TEAM_ID);
        const canceledState = states.find(
          (s) => s.type === "canceled" || s.name.toLowerCase().includes("cancel"),
        );
        if (canceledState) {
          await api.updateIssue(sessionIssueId, { stateId: canceledState.id });
        }
      } catch {
        // Best effort
      }
    });
  });

  describe("sub-issue decomposition", () => {
    let parentIssueId: string | null = null;
    let parentIssueIdentifier: string | null = null;
    let subIssue1Id: string | null = null;
    let subIssue1Identifier: string | null = null;
    let subIssue2Id: string | null = null;
    let subIssue2Identifier: string | null = null;
    const recorded: Record<string, unknown> = {};

    let teamStates: Array<{ id: string; name: string; type: string }>;

    it("fetches team states for sub-issue tests", async () => {
      teamStates = await api.getTeamStates(TEAM_ID);
      expect(teamStates.length).toBeGreaterThan(0);
      recorded.teamStates = teamStates;
    });

    it("creates a parent issue", async () => {
      const backlogState = teamStates.find((s) => s.type === "backlog");
      expect(backlogState).toBeTruthy();

      const result = await api.createIssue({
        teamId: TEAM_ID,
        title: "[SMOKE TEST] Sub-Issue Parent: Search Feature",
        description:
          "Auto-generated by smoke test to verify sub-issue decomposition.\n\n" +
          "This parent issue should have two sub-issues created under it.\n\n" +
          `Created: ${new Date().toISOString()}`,
        stateId: backlogState!.id,
        priority: 4,
      });

      expect(result.id).toBeTruthy();
      expect(result.identifier).toBeTruthy();
      parentIssueId = result.id;
      parentIssueIdentifier = result.identifier;
      recorded.createParent = result;
      console.log(`Created parent issue: ${result.identifier} (${result.id})`);
    });

    it("creates sub-issue 1 under parent (Backend API)", async () => {
      expect(parentIssueId).toBeTruthy();
      const backlogState = teamStates.find((s) => s.type === "backlog");

      const result = await api.createIssue({
        teamId: TEAM_ID,
        title: "[SMOKE TEST] Sub-Issue 1: Backend API",
        description:
          "Implement the backend search API endpoint.\n\n" +
          "Given a search query, when the API is called, then matching results are returned.",
        stateId: backlogState!.id,
        parentId: parentIssueId!,
        priority: 3,
        estimate: 2,
      });

      expect(result.id).toBeTruthy();
      expect(result.identifier).toBeTruthy();
      subIssue1Id = result.id;
      subIssue1Identifier = result.identifier;
      recorded.createSubIssue1 = result;
      console.log(`Created sub-issue 1: ${result.identifier} (parentId=${parentIssueId})`);
    });

    it("creates sub-issue 2 under parent (Frontend UI)", async () => {
      expect(parentIssueId).toBeTruthy();
      const backlogState = teamStates.find((s) => s.type === "backlog");

      const result = await api.createIssue({
        teamId: TEAM_ID,
        title: "[SMOKE TEST] Sub-Issue 2: Frontend UI",
        description:
          "Build the frontend search UI component.\n\n" +
          "Given the search page loads, when the user types a query, then results display in real-time.",
        stateId: backlogState!.id,
        parentId: parentIssueId!,
        priority: 3,
        estimate: 3,
      });

      expect(result.id).toBeTruthy();
      expect(result.identifier).toBeTruthy();
      subIssue2Id = result.id;
      subIssue2Identifier = result.identifier;
      recorded.createSubIssue2 = result;
      console.log(`Created sub-issue 2: ${result.identifier} (parentId=${parentIssueId})`);
    });

    it("sub-issue 1 has parent field pointing to parent", async () => {
      expect(subIssue1Id).toBeTruthy();
      const details = await api.getIssueDetails(subIssue1Id!);

      expect(details.parent).not.toBeNull();
      expect(details.parent!.id).toBe(parentIssueId);
      expect(details.parent!.identifier).toBe(parentIssueIdentifier);
      recorded.subIssue1Details = details;
      console.log(`Sub-issue 1 parent: ${details.parent!.identifier}`);
    });

    it("sub-issue 2 has parent field pointing to parent", async () => {
      expect(subIssue2Id).toBeTruthy();
      const details = await api.getIssueDetails(subIssue2Id!);

      expect(details.parent).not.toBeNull();
      expect(details.parent!.id).toBe(parentIssueId);
      expect(details.parent!.identifier).toBe(parentIssueIdentifier);
      recorded.subIssue2Details = details;
      console.log(`Sub-issue 2 parent: ${details.parent!.identifier}`);
    });

    it("parent issue has no parent (it is the root)", async () => {
      expect(parentIssueId).toBeTruthy();
      const details = await api.getIssueDetails(parentIssueId!);

      expect(details.parent).toBeNull();
      recorded.parentDetails = details;
    });

    it("creates blocks relation (sub-issue 1 blocks sub-issue 2)", async () => {
      expect(subIssue1Id).toBeTruthy();
      expect(subIssue2Id).toBeTruthy();

      const result = await api.createIssueRelation({
        issueId: subIssue1Id!,
        relatedIssueId: subIssue2Id!,
        type: "blocks",
      });

      expect(result.id).toBeTruthy();
      recorded.createRelation = result;
      console.log(`Created blocks relation: ${subIssue1Identifier} blocks ${subIssue2Identifier}`);
    });

    it("sub-issue 1 shows blocks relation to sub-issue 2", async () => {
      expect(subIssue1Id).toBeTruthy();
      const details = await api.getIssueDetails(subIssue1Id!);
      const blocksRels = details.relations.nodes.filter(
        (r) => r.type === "blocks",
      );

      expect(blocksRels.length).toBeGreaterThan(0);
      expect(
        blocksRels.some((r) => r.relatedIssue.id === subIssue2Id),
      ).toBe(true);
      recorded.subIssue1WithRelation = details;
      console.log(`Sub-issue 1 blocks: ${blocksRels.map((r) => r.relatedIssue.identifier).join(", ")}`);
    });

    it("sub-issue 2 shows inverse relation", async () => {
      expect(subIssue2Id).toBeTruthy();
      const details = await api.getIssueDetails(subIssue2Id!);

      // Linear may or may not populate an inverse "is_blocked_by" relation.
      // Record whatever we get — the mock test replays it as-is.
      recorded.subIssue2WithRelation = details;
      const rels = details.relations.nodes;
      console.log(
        `Sub-issue 2 relations: ${rels.length > 0 ? rels.map((r) => `${r.type} ${r.relatedIssue.identifier}`).join(", ") : "(none — inverse may not be returned)"}`,
      );
    });

    it("saves recorded API responses to fixture file", () => {
      // Only write if we actually ran the full flow
      if (!parentIssueId || !subIssue1Id || !subIssue2Id) {
        console.log("Skipping fixture write — not all issues were created.");
        return;
      }

      const fixturePath = join(
        __dirname,
        "fixtures",
        "recorded-sub-issue-flow.ts",
      );
      const content =
        `/**\n` +
        ` * Recorded API responses from sub-issue decomposition smoke test.\n` +
        ` * Auto-generated — do not edit manually.\n` +
        ` * Re-generate by running: npx vitest run src/__test__/smoke-linear-api.test.ts\n` +
        ` * Last recorded: ${new Date().toISOString()}\n` +
        ` */\n\n` +
        `export const RECORDED = ${JSON.stringify(recorded, null, 2)};\n`;

      writeFileSync(fixturePath, content, "utf8");
      console.log(`Recorded fixture written to: ${fixturePath}`);
    });

    it("cleans up: cancels parent and sub-issues", async () => {
      const canceledState = teamStates?.find(
        (s) => s.type === "canceled" || s.name.toLowerCase().includes("cancel"),
      );

      for (const id of [subIssue1Id, subIssue2Id, parentIssueId]) {
        if (!id || !canceledState) continue;
        try {
          await api.updateIssue(id, { stateId: canceledState.id });
        } catch {
          // Best effort
        }
      }
    });
  });

  describe("cleanup", () => {
    it("cancels the smoke test issue", async () => {
      if (!smokeIssueId) return;

      // Move to cancelled state if available, otherwise just leave it
      try {
        const states = await api.getTeamStates(TEAM_ID);
        const cancelledState = states.find(
          (s) => s.type === "cancelled" || s.name.toLowerCase().includes("cancel"),
        );
        if (cancelledState) {
          await api.updateIssue(smokeIssueId, { stateId: cancelledState.id });
        }
      } catch {
        // Best effort cleanup
      }
    });
  });
});
